use rand::Rng;
use csv::ReaderBuilder;
use plotters::prelude::*;

// Structure to represent an item in the knapsack problem
#[derive(Debug, Clone)]
struct Item {
    weight: u32,
    profit: u32,
}

// Read items from a file and return a vector of items
fn read_items(file_path: &str) -> Vec<Item> {
    let mut reader = ReaderBuilder::new()
        .has_headers(true)
        .from_path(file_path)
        .expect("Failed to read file");

    let mut items = Vec::new();

    for item in reader.records() {
        let item = item.expect("Failed to read item");
        let weight: u32 = item[2].parse().expect("Failed to parse weight");
        let profit: u32 = item[1].parse().expect("Failed to parse profit");
        items.push(Item { weight, profit });
    }

    items
}

// Generate a population with a size
// Each individual is represented as a vector of booleans (bitstring)
fn generate_population(population_size: u32, item_count: usize) -> Vec<Vec<bool>> {
    let mut population = Vec::new();
    let mut rng = rand::thread_rng();

    for _ in 0..population_size {
        let mut individual = Vec::new();
        for _ in 0..item_count {
            individual.push(rng.gen_bool(0.5));
        }
        population.push(individual);
    }

    population
}

// Fitness function to evaluate an individual
// The fitness is the sum of the profits of the items in the knapsack
// Individuals get a penalty if the weight of the items exceeds the capacity
fn fitness(individual: &Vec<bool>, items: &Vec<Item>, max_capacity: u32) -> i64 {
    let mut total_weight = 0;
    let mut total_profit = 0;

    for (i, item) in individual.iter().enumerate() {
        if *item {
            total_weight += items[i].weight;
            total_profit += items[i].profit;
        }
    }

    // Apply penalty if the weight exceeds the capacity
    if total_weight > max_capacity {
        let penalty: i64 = (total_weight - max_capacity) as i64 * 10;
        return total_profit as i64 - penalty;
    }

    total_profit as i64
}

// Tournament selection
fn tournament_selection(population: &Vec<Vec<bool>>, tournament_size: u32, items: &Vec<Item>, max_capacity: u32) -> Vec<Vec<bool>> {
    let mut rng = rand::thread_rng();
    let mut selected_parents = Vec::new();

    for _ in 0..population.len() {
        let mut tournament = Vec::new();
        for _ in 0..tournament_size {
            let random_index = rng.gen_range(0..population.len());
            tournament.push(population[random_index].clone());
        }

        let best_individual = tournament.iter().max_by_key(|individual| fitness(individual, &items, max_capacity)).unwrap();
        selected_parents.push(best_individual.clone());
    }

    selected_parents
}

// Crossover between two parents
// A random crossover point is selected
// Two children are generated by swapping the genes of the parents
fn crossover(parent1: &Vec<bool>, parent2: &Vec<bool>) -> Vec<Vec<bool>> {
    let mut rng = rand::thread_rng();
    let crossover_point = rng.gen_range(0..parent1.len()); // Random crossover point
    let mut child1 = parent1[..crossover_point].to_vec();
    let mut child2 = parent2[..crossover_point].to_vec();

    for i in crossover_point..parent1.len() {
        child1.push(parent2[i]);
        child2.push(parent1[i]);
    }

    vec![child1, child2]
}

// Mutation of an individual
// A random gene is selected and flipped
fn mutation(individual: &Vec<bool>, mutation_rate: f64) -> Vec<bool> {
    let mut rng = rand::thread_rng();
    let mut mutated_individual = individual.clone();

    for i in 0..individual.len() {
        if rng.gen_range(0.0..1.0) < mutation_rate {
            mutated_individual[i] = !mutated_individual[i];
        }
    }

    mutated_individual
}

// Elitism
// Keep the best individuals of the population
fn elitism(population: &Vec<Vec<bool>>, fitness_values: &Vec<i64>, elite_size: u32) -> Vec<Vec<bool>> {
    let mut elite_population = Vec::new();
    let mut population_with_fitness: Vec<_> = population.iter().zip(fitness_values).collect();
    population_with_fitness.sort_by(|a, b| b.1.cmp(a.1));

    for i in 0..elite_size {
        elite_population.push(population_with_fitness[i as usize].0.clone());
    }

    elite_population
}

// Genetic algorithm
fn genetic_algorithm(init_population: Vec<Vec<bool>>, items: Vec<Item>, max_capacity: u32, iterations: u32) {
    let mut population = init_population;
    let population_size = population.len();
    let mut data = Vec::new();
    
    for iteration in 0..iterations {
        // Evaluate fitness of each individual
        let fitness_values: Vec<i64> = population.iter().map(|individual| fitness(individual, &items, max_capacity)).collect();

        // Print best and average fitness of the population
        if iteration % 10 == 0 {
            let best_fitness = fitness_values.iter().max().unwrap();
            let avg_fitness = fitness_values.iter().sum::<i64>() / fitness_values.len() as i64;
            println!("Iteration: {}, Best fitness: {}, Average fitness: {}", iteration, best_fitness, avg_fitness);
        }

        // Save data for plotting
        data.push((iteration, *fitness_values.iter().max().unwrap(), fitness_values.iter().sum::<i64>() / fitness_values.len() as i64, *fitness_values.iter().min().unwrap()));

        // Select parents
        let selected_parents = tournament_selection(&population, 5, &items, max_capacity);

        // Generate offspring
        let mut offspring = Vec::new();
        for i in 0..selected_parents.len() / 2 {
            let children = crossover(&selected_parents[i * 2], &selected_parents[i * 2 + 1]);
            offspring.push(children[0].clone());
            offspring.push(children[1].clone());
        }

        // Offspring mutation
        let mutation_rate = 1.0 / population[0].len() as f64; // In average, each gene will be mutated once
        let mutated_offspring: Vec<Vec<bool>> = offspring.iter().map(|individual| mutation(individual, mutation_rate)).collect();

        // Replace population with the best individuals
        let elite_population = elitism(&population, &fitness_values, population.len() as u32 / 3);
        population = elite_population.clone();

        // Fill the rest of the population with offspring, keep the population size constant
        while population.len() < population_size {
            population.push(mutated_offspring[population.len() - elite_population.len()].clone());
        }
    }

    // Plot the data
    plot_data(data);
}

// Plot the data
// 99% from ChatGPT lol
fn plot_data(data: Vec<(u32, i64, i64, i64)>) {
    let root = BitMapBackend::new("output/knapsack_plot.png", (800, 600)).into_drawing_area();
    root.fill(&WHITE).unwrap();

    // Determine the minimum and maximum y values
    let min_y = 125000; // Start y-axis from 125000
    let max_y = *data.iter().map(|(_, best, _, _)| best).max().unwrap();

    let mut chart = ChartBuilder::on(&root)
        .caption("Knapsack Problem", ("Arial", 30).into_font())
        .margin(5)
        .x_label_area_size(40)
        .y_label_area_size(40)
        .build_cartesian_2d(0..data.len() as u32, min_y..max_y)
        .unwrap();

    chart
        .configure_mesh()
        .x_desc("Iterations")
        .y_desc("Fitness Value")
        .axis_desc_style(("Arial", 15))
        .draw()
        .unwrap();

    // Draw the best fitness line
    chart
        .draw_series(LineSeries::new(
            data.iter().map(|(x, y, _, _)| (*x, *y)),
            &RED,
        ))
        .unwrap()
        .label("Best Fitness")
        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &RED));

    // Draw the average fitness line
    chart
        .draw_series(LineSeries::new(
            data.iter().map(|(x, _, y, _)| (*x, *y)),
            &BLUE,
        ))
        .unwrap()
        .label("Average Fitness")
        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &BLUE));

    // Draw the minimum fitness line
    chart
        .draw_series(LineSeries::new(
            data.iter().map(|(x, _, _, y)| (*x, *y)),
            &GREEN,
        ))
        .unwrap()
        .label("Minimum Fitness")
        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &GREEN));

    // Configure the legend
    chart
        .configure_series_labels()
        .background_style(&WHITE.mix(0.8))
        .border_style(&BLACK)
        .draw()
        .unwrap();
}

// Main function
fn main() {
    println!("Starting knapsack problem");

    // Read items from file
    println!("Reading items:");
    let items = read_items("data/knapPI_12_500_1000_82.csv");
    println!("Number of items: {}", items.len());

    // Generate population
    println!("Generating population:");
    let population = generate_population(100, items.len());
    println!("Size of population: {}, Items per individual: {}", population.len(), population[0].len());

    println!();

    // Start genetic algorithm
    println!("Starting genetic algorithm:");
    genetic_algorithm(population, items, 280785, 61);
}